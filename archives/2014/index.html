<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>归档：2014 | SparkleMan</title>
  <meta name="author" content="SparkleMan">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="SparkleMan"/>

  
    <meta property="og:image" content="undefined"/>
  

  <link href="/blog/favicon.png" rel="icon">
  <link rel="alternate" href="/blog/atom.xml" title="SparkleMan" type="application/atom+xml">
  <link rel="stylesheet" href="/blog/css/style.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
  
</head>


<body>
  <header id="header" class="inner"><div class="alignleft">
  <h1><a href="/blog/">SparkleMan</a></h1>
  <h2><a href="/blog/">A ship in port is safe, but that is not what ships are built for.</a></h2>
</div>
<nav id="main-nav" class="alignright">
  <ul>
    
      <li><a href="/blog">Home</a></li>
    
      <li><a href="/blog/archives">Archives</a></li>
    
  </ul>
  <div class="clearfix"></div>
</nav>
<div class="clearfix"></div></header>
  <div id="content" class="inner">
    <div id="main-col" class="alignleft"><div id="wrapper">
<h2 class="archive-title">2014</h2>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-05-10T04:18:57.000Z"><a href="/blog/2014/05/10/enhance-window-console/">5月 10 2014</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/05/10/enhance-window-console/">加强 Windows 控制台程序</a></h1>
  

    </header>
    <div class="entry">
      
        <p>用过 <code>linux shell</code> 人，会发现 <code>windows</code> 的控制台程序简直是弱爆了。虽然微软后续退出的 <code>powershell</code> 一定程度上提升了 <code>windows</code> 下的控制台程序能力，但是对于在控制台程序打开多标签等功能还比较欠缺。本文介绍几款对 <code>windows</code> 控制台程序加强的软件，由于只是初步涉猎，后续深入使用后，有更多体会再补充。</p>
<h2 id="console2">Console2</h2>
<p>并不提供 shell 能力，只是提供了一个用户界面，可以集成各种 shell，可以认为各种 shell 的一个壳，因此打开多标签啥的肯定没啥问题。</p>
<ul>
<li>开源软件</li>
<li><a href="http://sourceforge.net/projects/console/files/" target="_blank">下载地址</a></li>
<li>主要功能特性<ol>
<li>支持多标签功能；</li>
<li>支持可配置的字体、背景、透明度，文本选择、快捷键等；</li>
<li>支持集成各种 shell， 包括控制台程序、powershell等；</li>
</ol>
</li>
<li>缺点<ol>
<li>不支持中文输入;</li>
<li>无法最大化。</li>
</ol>
</li>
</ul>
<p><strong> 安装使用的注意点： </strong></p>
<ol>
<li>设置font的时候选择字符集为中欧字符集，否则中文会乱码</li>
<li>如果不想切换窗口时候console始终在顶层，设置 <code>position</code> 为 <code>always on top</code></li>
<li>打开控制台程序包括powershell都是显示错位，右对齐，解决办法：右键 <code>view-&gt;console window</code> 这时会弹出一个命令行窗口，点击标题栏右键选择属性，弹出设置框里选择字体 改成 宋体，确定保存退出，重新打开console2就好了。</li>
<li>对于添加自定义的Tab的Shell，可以设置自定义的 Tab 的标题和 Icon，对于Icon设置，推荐一款软件：
<a href="http://icofx.ro/" target="_blank">icofx</a>，不错的icon编辑和提取软件，可以提取应用程序的icon哦，选择带图标的exe文件，会自动提取该exe所对应的图标。</li>
<li>快捷键修改， <code>ctrl s</code> 打开设置对话框，到HotKeys下对于 <code>new tab 1</code> (设成 ctrl + t)、<code>copy selection</code> (这里最好不要设成 ctrl + c，否则要中断程序就没用了，可以设成 ctrl + shift + c)、<code>paste</code> (设成 ctrl + v)。修改快捷键时候，通过按键来修改，修改完要点下 <code>assign</code> 按钮。</li>
<li>可以在 <code>console</code> 选择里通过设置 <code>startup dir</code>，来设置每次启动命令行程序初始目录。</li>
</ol>
<h2 id="conemu">ConEmu</h2>
<p>跟 <code>console2</code> 一样也是提供各种shell的壳，待慢慢研究后再补充。</p>
<ul>
<li>开源软件</li>
<li><a href="https://github.com/Maximus5/ConEmu" target="_blank">官方网站</a></li>
</ul>
<h2 id="clink">Clink</h2>
<p>加强 windows 的 cmd 程序的各种不足，比如输入补全等。对于 <code>powershell</code> 的输入补全，可以用这个 <a href="http://powertab.codeplex.com/" target="_blank">powerTab</a></p>
<ul>
<li>开源软件</li>
<li><a href="http://mridgers.github.io/clink/" target="_blank">官方网站</a></li>
</ul>
<h2 id="-">参考</h2>
<p><a href="http://www.cnblogs.com/bamanzi/archive/2012/06/27/windows-console-emulater.html" target="_blank"><a href="http://www.cnblogs.com/bamanzi/archive/2012/06/27/windows-console-emulater.html">http://www.cnblogs.com/bamanzi/archive/2012/06/27/windows-console-emulater.html</a></a></p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  
    <article class="post">
  
    <div class="gallery">
  <div class="photoset">
    
      <img src="">
    
  </div>
  <div class="control">
    <div class="prev"></div>
    <div class="next"></div>
  </div>
</div>
  
  <div class="post-content">
    <header>
      
        <div class="icon"></div>
        <time datetime="2014-03-03T07:41:09.000Z"><a href="/blog/2014/03/03/promise_anti_patterns/">3月 3 2014</a></time>
      
      
  
    <h1 class="title"><a href="/blog/2014/03/03/promise_anti_patterns/">Prmoise反模式</a></h1>
  

    </header>
    <div class="entry">
      
        <p>翻译自<a href="http://taoofcode.net/promise-anti-patterns/" target="_blank">Promise Anti Promises</a>，这不是简单翻译，而是在自己理解上做的翻译，因此本文并不是逐句翻译的文章。</p>
<p>说明：下述代码都是基于promise规范实现的库：<a href="https://github.com/kriskowal/q" target="_blank">q</a></p>
<h2 id="-promise">嵌套Promise</h2>
<p>这段代码要做的事情，就是等待两个promise完成后在做其它事情。</p>
<figure class="highlight [javascript]"><figcaption><span>[Netsted Promise - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre>loadSomething().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(something)</span></span> {  
    loadAnotherThing().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(another)</span></span> {
                    doSomethingOnThem(something, another);
    });
});
</pre></td></tr></table></figure>

<p>之所以写出这种代码，在于对于promise的api不了解，promise提供了一个 <code>all</code> 方法来完成上面事情，因此更好的代码应该这样：</p>
<figure class="highlight [javascript]"><figcaption><span>[Netsted Promise - Fixed] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
</pre></td><td class="code"><pre>q.all([loadSomething(), loadAnotherThing()])  
    .spread(<span class="function"><span class="keyword">function</span><span class="params">(something, another)</span> {</span>
        doSomethingOnThem(something, another);
});
</pre></td></tr></table></figure>

<p><code>all</code> 方法会等待所有传入该方法的promise都完成才触发完成状态。<code>spread</code> 方法会把返回的数组结果分拆成一个个元素作为参数传入回调函数里。</p>
<h2 id="-">破裂的链式写法</h2>
<p>promise出现可以让我们以更加自然的链式写法来书写代码，但是当出现如下这种代码时候，会有啥问题呢？</p>
<figure class="highlight [javascript]"><figcaption><span>[Broken Chain - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> {</span>  
    <span class="keyword">var</span> promise = doSomethingAsync();
    promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        somethingComplicated();
    });

    <span class="keyword">return</span> promise;
}
</pre></td></tr></table></figure>

<p>首先，必须清楚 <code>anAsyncCall</code> 方法返回的promise跟该方法内部 <code>then</code> 返回的promise并不一定是同一个promise，
<a href="http://promises-aplus.github.io/promises-spec/" target="_blank">Promise A+</a>规范并不要求链式写法过程返回的promise
必须跟一开始的promise是同一个promise：
参见
<a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank">Promise A</a>规范
和
<a href="http://promises-aplus.github.io/promises-spec/" target="_blank">Prmoise A+</a>规范
<a href="https://github.com/promises-aplus/promises-spec/blob/master/differences-from-promises-a.md" target="_blank">比较</a>。</p>
<p>因此， 这可能导致一个问题，假设 <code>then</code> 回调里的 <code>somethingComplicated</code> 方法出错了，该异常将不会得到处理！</p>
<p>更好的实现代码：</p>
<figure class="highlight [javascript]"><figcaption><span>[Broken Chain - Fixed] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">anAsyncCall</span><span class="params">()</span> {</span>  
    <span class="keyword">var</span> promise = doSomethingAsync();
    <span class="keyword">return</span> promise.then(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        somethingComplicated()
    });   
}
</pre></td></tr></table></figure>

<h2 id="-">混乱的集合操作</h2>
<p>下面代码做的事情，就是对给定的数组集合的每个元素都执行异步的操作，然后收集所有元素的异步操作的执行结果。</p>
<figure class="highlight [javascript]"><figcaption><span>[Collection Kerfuffle - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> {  </span>
    var resultArr = <span class="matrix">[]</span>;
    <span class="function"><span class="keyword">function</span> <span class="title">_recursive</span><span class="params">(idx)</span> {</span>
        <span class="keyword">if</span> (idx &gt;= <span class="transposed_variable">resultArr.</span><span class="built_in">length</span>) <span class="keyword">return</span> resultArr;

        <span class="keyword">return</span> doSomethingAsync(arr<span class="matrix">[idx]</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span> {</span>
            <span class="transposed_variable">resultArr.</span>push(res);
            <span class="keyword">return</span> _recursive(idx + <span class="number">1</span>);
        });
    }

    <span class="keyword">return</span> _recursive(<span class="number">0</span>);
}
</pre></td></tr></table></figure>

<p>其实上面操作就是一个map/readuce过程，可以基于数组的map和reduce方法来完成，
当然这里不考虑一些老旧浏览器不支持map/reduce方法问题：</p>
<figure class="highlight [javascript]"><figcaption><span>[Collection Kerfuffle - Fixed - in Parallel] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span> {</span>  
    <span class="keyword">return</span> q.all(arr.map(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> {</span>
        <span class="keyword">return</span> doSomethingAsync(item);
    }));    
}
</pre></td></tr></table></figure>

<p>上述代码，基于 <code>all</code> 方法来完成，对于array元素为并行处理，如果想串行处理数组元素，可以基于
数组的reduce方法来完成：</p>
<figure class="highlight [javascript]"><figcaption><span>[Collection Kerfuffle - Fixed - in Series] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre><span class="function"><span class="keyword">function</span> <span class="title">workMyCollection</span><span class="params">(arr)</span></span> {  
    <span class="keyword">return</span> arr.reduce(<span class="function"><span class="keyword">function</span><span class="params">(promise, item)</span></span> {
        <span class="keyword">return</span> promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(result)</span></span> {
            <span class="keyword">return</span> doSomethingAsyncWithResult(item, result);
        });        
    }, q());
}
</pre></td></tr></table></figure>

<h2 id="the-ghost-promise-">The Ghost Promise (不知道咋翻译。。)</h2>
<p>我们通常会碰到这样的需求，有些情况下需要返回异步操作的promise，但有时候却不需要，比如缓存过程，比如第一次不在缓存，就
需要异步操作，下次再请求，如果已经完成了，就直接返回已经得到的结果：</p>
<figure class="highlight [javascript]"><figcaption><span>[Ghost Promise - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> promise;  
<span class="keyword">if</span> (asyncCallNeeded)  
    promise = doSomethingAsync();
<span class="keyword">else</span>  
    promise = Q.resolve(<span class="number">42</span>);

promise.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="comment">{  
    doSomethingCool();
}</span>);</span>
</pre></td></tr></table></figure>

<p>虽然上面代码在反模式里并不算太糟，但是还有更好的方式来实现，当然这里依托于q库实现：</p>
<figure class="highlight [javascript]"><figcaption><span>[Ghost Promise - Good] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre>Q(asyncCallNeeded ? doSomethingAsync() : <span class="number">42</span>)  
    .<span class="keyword">then</span>(
        <span class="function"><span class="keyword">function</span><span class="params">(value)</span>{</span>
            doSomethingGood();
        })
    .<span class="keyword">catch</span>( 
        <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
            handleTheError();
        });
</pre></td></tr></table></figure>

<h2 id="-">过度专注错误的处理</h2>
<p>虽然下面在then里进行错误处理，貌似没啥问题，这种习惯性错误处理方式，可能导致漏掉一些潜在可能错误处理，
比如如果 <code>somethingElseAsync</code> 方法抛出错误，将导致错误没有得到捕获处理。</p>
<figure class="highlight [javascript]"><figcaption><span>[Overly Keen Error Handler - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>somethingAsync.<span class="keyword">then</span>(  
    <span class="function"><span class="keyword">function</span><span class="params">()</span></span> {
        <span class="keyword">return</span> somethingElseAsync();
    },
    <span class="function"><span class="keyword">function</span><span class="params">(err)</span></span> {
        handleMyError(err);
});
</pre></td></tr></table></figure>

<p>为了更好捕获错误处理，更好的代码应该这样：</p>
<figure class="highlight [javascript]"><figcaption><span>[Overly Keen Error Handler - Fixed] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
</pre></td><td class="code"><pre>somethingAsync  
    .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span> {
        <span class="keyword">return</span> somethingElseAsync();
    })
    .<span class="keyword">then</span>(null,
        <span class="function"><span class="keyword">function</span><span class="params">(err)</span></span> {
            handleMyError(err);
        });
</pre></td></tr></table></figure>

<figure class="highlight [javascript]"><figcaption><span>[Overly Keen Error Handler - Another Fixed] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
</pre></td><td class="code"><pre>somethingAsync  
    .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> {</span>
        <span class="keyword">return</span> somethingElseAsync();
    })
    .<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
        handleMyError(err);
    });
</pre></td></tr></table></figure>

<p>当然个人感觉这个有点极端，如果 <code>handleMyError</code> 也有错误了，岂不是这种then写法永远没有完美的方式。
我想promise对于错误捕获，应该是那些可预知的，对于不可预知的捕获或者不期望出现的，我觉得应该
通过代码测试保证，比如语法错误等。当然promise的规范，导致可能任何不期望错误都会被捕获，导致平时
开发调试测试会痛苦，因为我们更期望把这些错误抛出来，更早被发现，而不是被吞掉。对此，有些promise库
会提供全局的错误监听和处理机制。</p>
<h2 id="-promise">遗忘的Promise</h2>
<p>经常我们在处理promise的响应时候，有时候想在后面链式操作时候，使用我们预处理过的数据，而不是直接使用
直接响应的结果，通常我们会这么做：</p>
<figure class="highlight [javascript]"><figcaption><span>[Forgotten Promise - Bad] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
4
5
6
7
8
9
</pre></td><td class="code"><pre><span class="keyword">var</span> deferred = Q.defer();  
doSomethingAsync().then(<span class="function"><span class="keyword">function</span><span class="params">(res)</span> {</span>  
    res = manipulateMeInSomeWay(res);
    deferred.resolve(res);
}, <span class="function"><span class="keyword">function</span><span class="params">(err)</span> {</span>
    deferred.reject(err);
});

<span class="keyword">return</span> deferred.promise;
</pre></td></tr></table></figure>

<p>当看到这样代码时候，我想在于我们没有真正理解promise的接口规范，只懂的链式操作 <code>then</code>，对于链式操作回调的
参数没有真正弄明白。</p>
<p>更好的代码应该是这样的：</p>
<figure class="highlight [javascript]"><figcaption><span>[Forgotten Promise - Good] </span></figcaption><table><tr><td class="gutter"><pre>1
2
3
</pre></td><td class="code"><pre><span class="keyword">return</span> doSomethingAsync().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(res)</span></span> {  
    <span class="keyword">return</span> manipulateMeInSomeWay(res);
});
</pre></td></tr></table></figure>

<p>每个链式回调参数为上一个then回调处理返回的结果，当然如果上一个then回调返回是promise，则参数为该promise
状态变更传入的参数。</p>

      
    </div>
    <footer>
      
        
        
      
      <div class="clearfix"></div>
    </footer>
  </div>
</article>


  

  <nav id="pagination">
  
  
  <div class="clearfix"></div>
</nav>
</div></div>
    <aside id="sidebar" class="alignright">
  <div class="search">
  <form action="//google.com/search" method="get" accept-charset="utf-8">
    <input type="search" name="q" results="0" placeholder="搜索">
    <input type="hidden" name="q" value="site:sparkleman.github.io/blog">
  </form>
</div>

  

  
<div class="widget tag">
  <h3 class="title">标签</h3>
  <ul class="entry">
  
    <li><a href="/blog/tags/hexo/">hexo</a><small>1</small></li>
  
    <li><a href="/blog/tags/javascript jshint/">javascript jshint</a><small>1</small></li>
  
    <li><a href="/blog/tags/promise javascript/">promise javascript</a><small>1</small></li>
  
    <li><a href="/blog/tags/windows shell powershell console/">windows shell powershell console</a><small>1</small></li>
  
  </ul>
</div>

</aside>
    <div class="clearfix"></div>
  </div>
  <footer id="footer" class="inner"><div class="alignleft">
  
  &copy; 2014 SparkleMan
  
</div>
<div class="clearfix"></div></footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/blog/js/jquery.imagesloaded.min.js"></script>
<script src="/blog/js/gallery.js"></script>




<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>

</body>
</html>